document.addEventListener('DOMContentLoaded', () => {
    const state = {
        selectedFiles: [],
        isStreaming: false,
        uploadInProgress: false,
        saveTimeout: null,
        currentThreadId: null,
        renameThreadId: null,
        abortController: null,
        systemPrompt: localStorage.getItem('systemPrompt') || 'You are a helpful assistant.',
    };
    const elements = {
        modelDropdown: document.getElementById('model-dropdown'),
        messageInput: document.getElementById('message-input'),
        sendButton: document.getElementById('send-button'),
        chatMessages: document.getElementById('chat-messages'),
        selectedFilesDisplay: document.getElementById('selected-files-display'),
        fileInput: document.getElementById('file'),
        uploadStatus: document.getElementById('upload-status'),
        filesContainer: document.getElementById('files-container'),
        clearConversationBtn: document.getElementById('clear-conversation'),
        dragDropArea: document.getElementById('drag-drop-area'),
        settingsButton: document.getElementById('settings-button'),
        settingsModal: document.getElementById('settings-modal'),
        systemPromptInput: document.getElementById('system-prompt-input'),
        saveStatusDiv: document.getElementById('save-status'),
        newThreadBtn: document.getElementById('new-thread-btn'),
        threadsContainer: document.getElementById('threads-container'),
        renameThreadModal: document.getElementById('rename-thread-modal'),
        threadNameInput: document.getElementById('thread-name-input'),
        cancelRenameBtn: document.getElementById('cancel-rename-btn'),
        confirmRenameBtn: document.getElementById('confirm-rename-btn'),
        topMessageInserter: null, 
    };
    const WELCOME_MESSAGE_HTML = `
        <div class="welcome-message">
            <h2>Welcome to Ollama Chat!</h2>
            <p>Select a model from the dropdown, optionally select files to reference, and start chatting.</p>
        </div>`;
    const SHORT_MESSAGE_THRESHOLD = 100; 
    const api = {
        async _fetchAPI(url, options = {}) {
            const defaultHeaders = {
                'Accept': 'application/json',
                ...(options.body && !(options.body instanceof FormData) && { 'Content-Type': 'application/json' }), 
            };
            try {
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        ...defaultHeaders,
                        ...options.headers,
                    },
                    credentials: 'include', 
                });
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: await response.text() || `HTTP error! status: ${response.status}` };
                    }
                    console.error(`API Error (${response.status}) for ${url}:`, errorData);
                    return { success: false, error: errorData.error || `HTTP ${response.status}` };
                }
                if (response.status === 204) {
                    return { success: true, data: null };
                }
                const data = await response.json();
                return { success: true, data };
            } catch (error) {
                console.error(`Network or fetch error for ${url}:`, error);
                return { success: false, error: error.message || 'Network error' };
            }
        },
        async fetchModels() {
            const result = await this._fetchAPI('/api/models');
            if (result.success && result.data) {
                ui.displayModels(result.data); 
            } else {
                console.error("Failed to fetch models:", result.error);
                ui.displayModels([]); 
            }
            return result;
        },
        async fetchFiles() {
            const result = await this._fetchAPI('/api/files');
            if (result.success && result.data) {
                ui.displayFiles(result.data); 
            } else {
                console.error("Failed to fetch files:", result.error);
                ui.displayFiles([]); 
            }
            return result;
        },
        async fetchThreads() {
            const result = await this._fetchAPI('/api/threads');
            if (result.success && result.data) {
                state.currentThreadId = result.data.active_thread; 
                ui.displayThreads(result.data.threads || [], result.data.active_thread); 
            } else {
                console.error("Failed to fetch threads:", result.error);
                ui.displayThreads([], null); 
            }
            return result;
        },
        async fetchConversationHistory() {
            if (!state.currentThreadId) {
                console.warn("Attempted to fetch history with no active thread ID. Waiting for thread load.");
                ui.renderMessages([]); 
                return { success: false, error: "No active thread ID" };
            }
            console.log(`Fetching history for thread: ${state.currentThreadId}`);
            const result = await this._fetchAPI('/api/conversation/history'); 
            if (result.success && result.data) {
                 if (result.data.thread_id !== state.currentThreadId) {
                     console.warn(`History received for thread ${result.data.thread_id}, but expected ${state.currentThreadId}. State mismatch?`);
                     state.currentThreadId = result.data.thread_id; 
                     await api.fetchThreads(); 
                 }
                ui.renderMessages(result.data.history || []); 
            } else {
                console.error("Failed to fetch conversation history:", result.error);
                ui.renderMessages([]); 
            }
            return result;
        },
        async deleteFile(filename) {
            return await this._fetchAPI(`/api/files/${filename}`, { method: 'DELETE' });
        },
        async clearConversation() {
            return await this._fetchAPI('/api/conversation/clear', { method: 'POST' });
        },
        async createNewThread() {
            return await this._fetchAPI('/api/threads/new', { method: 'POST' });
        },
        async activateThread(threadId) {
            return await this._fetchAPI(`/api/threads/${threadId}/activate`, { method: 'POST' });
        },
        async renameThread(threadId, newName) {
            return await this._fetchAPI(`/api/threads/${threadId}/rename`, {
                method: 'POST',
                body: JSON.stringify({ name: newName }),
            });
        },
        async deleteThread(threadId) {
            return await this._fetchAPI(`/api/threads/${threadId}/delete`, { method: 'DELETE' });
        },
        async generateTitle(conversationData) {
            return await this._fetchAPI('/api/generate-title', {
                method: 'POST',
                body: JSON.stringify(conversationData),
            });
        },
        async deleteMessage(messageId) {
            return await this._fetchAPI(`/api/messages/${messageId}`, { method: 'DELETE' });
        },
        async updateMessage(messageId, newContent) {
            return await this._fetchAPI(`/api/messages/${messageId}`, {
                method: 'PUT',
                body: JSON.stringify({ content: newContent }),
            });
        },
        async insertMessage(precedingMessageId, role, content) {
            return await this._fetchAPI('/api/messages/insert', {
                method: 'POST',
                body: JSON.stringify({ precedingMessageId, role, content }),
            });
        }
    };
    const ui = {
        displayModels(models) {
            elements.modelDropdown.innerHTML = ''; 
            if (!models || models.length === 0) {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "No models available";
                elements.modelDropdown.appendChild(option);
                elements.modelDropdown.disabled = true;
                return;
            }
            elements.modelDropdown.disabled = false;
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = model.name;
                elements.modelDropdown.appendChild(option);
            });
            if (elements.modelDropdown.options.length > 0) {
                elements.modelDropdown.selectedIndex = 0;
            }
        },
        displayFiles(files) {
            elements.filesContainer.innerHTML = ''; 
            if (!files || files.length === 0) {
                elements.filesContainer.innerHTML = '<p>No files uploaded yet.</p>';
                return;
            }
            files.forEach(filename => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.dataset.filename = filename; 
                const fileNameDiv = document.createElement('div');
                fileNameDiv.className = 'file-name';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `file-${filename}`; 
                checkbox.dataset.filename = filename;
                checkbox.className = 'file-checkbox';
                checkbox.checked = state.selectedFiles.includes(filename); 
                const label = document.createElement('label');
                label.htmlFor = `file-${filename}`;
                label.textContent = filename;
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = `Delete ${filename}`;
                fileNameDiv.append(checkbox, label);
                fileItem.append(fileNameDiv, deleteBtn);
                elements.filesContainer.appendChild(fileItem);
            });
        },
        updateSelectedFilesDisplay() {
            elements.selectedFilesDisplay.innerHTML = ''; 
            if (state.selectedFiles.length === 0) {
                 elements.selectedFilesDisplay.style.display = 'none'; 
                 return;
            }
            elements.selectedFilesDisplay.style.display = 'flex'; 
            state.selectedFiles.forEach(filename => {
                const fileTag = document.createElement('div');
                fileTag.className = 'selected-file-tag';
                fileTag.dataset.filename = filename; 
                const fileNameSpan = document.createElement('span');
                fileNameSpan.textContent = filename;
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-file';
                removeButton.innerHTML = '×';
                removeButton.title = `Remove ${filename} from selection`;
                fileTag.append(fileNameSpan, removeButton);
                elements.selectedFilesDisplay.appendChild(fileTag);
            });
        },
        displayThreads(threads, activeThreadId) {
            elements.threadsContainer.innerHTML = ''; 
            if (!threads || threads.length === 0) {
                elements.threadsContainer.innerHTML = '<p class="no-threads-message">No threads yet</p>';
                return;
            }
            threads.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
            threads.forEach(thread => {
                const threadItem = document.createElement('div');
                threadItem.className = 'thread-item';
                threadItem.dataset.threadId = thread.id; 
                if (thread.id === activeThreadId) {
                    threadItem.classList.add('active');
                }
                const threadName = document.createElement('div');
                threadName.className = 'thread-name';
                threadName.textContent = thread.name || 'Untitled Thread'; 
                threadName.title = thread.name || 'Untitled Thread';
                const threadOptions = document.createElement('div');
                threadOptions.className = 'thread-options';
                const renameBtn = document.createElement('button');
                renameBtn.className = 'thread-option-btn rename-btn';
                renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
                renameBtn.title = 'Rename thread';
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'thread-option-btn delete-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete thread';
                threadOptions.append(renameBtn, deleteBtn);
                threadItem.append(threadName, threadOptions);
                elements.threadsContainer.appendChild(threadItem);
            });
        },
        renderMessages(messages) {
            console.log(`Rendering ${messages.length} messages.`);
            this.clearChatMessagesAndInserters();
            if (!messages || messages.length === 0) {
                this.addWelcomeMessage();
            } else {
                messages.forEach(msg => {
                    const sender = msg.role === 'assistant' ? 'bot' : msg.role; 
                    const messageElement = this.addMessageAndInserterToChat(
                        msg.content,
                        sender,
                        msg.thinking || null, 
                        msg.id 
                    );
                    this.processMessageContent(messageElement); 
                });
            }
            this.scrollToBottom(); 
        },
        clearChatMessagesAndInserters() {
            const messagesToRemove = elements.chatMessages.querySelectorAll('.message, .message-inserter:not(#top-message-inserter)');
            messagesToRemove.forEach(el => el.remove());
            const welcome = elements.chatMessages.querySelector('.welcome-message');
            if (welcome) welcome.remove();
        },
        addWelcomeMessage() {
            if (!elements.chatMessages.querySelector('.message')) {
                elements.chatMessages.insertAdjacentHTML('beforeend', WELCOME_MESSAGE_HTML);
            }
        },
        createMessageElement(content, sender, thinking, messageId) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`; 
            messageDiv.dataset.messageId = messageId || `temp-${sender}-${Date.now()}`;
            if (sender === 'bot' && thinking) {
                const thinkingDiv = document.createElement('div');
                thinkingDiv.className = 'thinking-section';
                const thinkingToggle = document.createElement('button');
                thinkingToggle.className = 'thinking-toggle';
                thinkingToggle.textContent = 'Show thinking';
                const thinkingContent = document.createElement('div');
                thinkingContent.className = 'thinking-content';
                thinkingContent.style.display = 'none'; 
                thinkingContent.innerHTML = this.formatMessage(thinking); 
                thinkingToggle.addEventListener('click', () => {
                    const isHidden = thinkingContent.style.display === 'none';
                    thinkingContent.style.display = isHidden ? 'block' : 'none';
                    thinkingToggle.textContent = isHidden ? 'Hide thinking' : 'Show thinking';
                    if (isHidden) {
                        thinkingContent.querySelectorAll('pre code').forEach(this.highlightElement);
                    }
                });
                thinkingDiv.append(thinkingToggle, thinkingContent);
                messageDiv.appendChild(thinkingDiv);
            }
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = this.formatMessage(content || ''); 
            messageDiv.appendChild(contentDiv);
            if (messageId && !messageId.startsWith('temp-')) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-message-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete message and subsequent history';
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-message-btn';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = 'Edit message and resubmit';
                actionsDiv.append(editBtn, deleteBtn); 
                messageDiv.appendChild(actionsDiv);
            }
            return messageDiv;
        },
        addMessageAndInserterToChat(content, sender, thinking, messageId) {
            const messageElement = this.createMessageElement(content, sender, thinking, messageId);
            const inserterElement = this.createMessageInserter(messageElement.dataset.messageId); 
            elements.chatMessages.appendChild(messageElement);
            elements.chatMessages.appendChild(inserterElement);
            return messageElement; 
        },
        updateMessageContent(messageElement, newContent, newThinking) {
            const contentDiv = messageElement.querySelector('.message-content');
            if (contentDiv) {
                contentDiv.innerHTML = this.formatMessage(newContent);
            }
            let thinkingDiv = messageElement.querySelector('.thinking-section');
            let thinkingContent = messageElement.querySelector('.thinking-content');
            if (newThinking !== null && newThinking !== undefined) {
                if (!thinkingDiv) {
                    thinkingDiv = document.createElement('div');
                    thinkingDiv.className = 'thinking-section';
                    const thinkingToggle = document.createElement('button');
                    thinkingToggle.className = 'thinking-toggle';
                    thinkingToggle.textContent = 'Show thinking'; 
                    thinkingContent = document.createElement('div');
                    thinkingContent.className = 'thinking-content';
                    thinkingContent.style.display = 'none'; 
                    thinkingToggle.addEventListener('click', () => { 
                        const isHidden = thinkingContent.style.display === 'none';
                        thinkingContent.style.display = isHidden ? 'block' : 'none';
                        thinkingToggle.textContent = isHidden ? 'Hide thinking' : 'Show thinking';
                         if (isHidden) thinkingContent.querySelectorAll('pre code').forEach(this.highlightElement);
                    });
                    thinkingDiv.append(thinkingToggle, thinkingContent);
                    if (contentDiv) {
                        messageElement.insertBefore(thinkingDiv, contentDiv);
                    } else {
                        messageElement.appendChild(thinkingDiv); 
                    }
                }
                thinkingContent.innerHTML = this.formatMessage(newThinking);
            } else if (thinkingDiv) {
                thinkingDiv.remove();
            }
            this.processMessageContent(messageElement);
        },
        formatMessage(content) {
            if (content === null || typeof content === 'undefined') {
                return '';
            }
            content = String(content); 
            function escapeHTML(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            const parts = [];
            let lastIndex = 0;
            const codeBlockRegex = /```(\w*)\n([\s\S]*?)```/g;
            let match;
            while ((match = codeBlockRegex.exec(content)) !== null) {
                if (match.index > lastIndex) {
                    parts.push({ type: 'text', content: escapeHTML(content.substring(lastIndex, match.index)) });
                }
                parts.push({
                    type: 'code',
                    language: match[1] || 'plaintext', 
                    content: escapeHTML(match[2]) 
                });
                lastIndex = match.index + match[0].length;
            }
            if (lastIndex < content.length) {
                parts.push({ type: 'text', content: escapeHTML(content.substring(lastIndex)) });
            }
            return parts.map(part => {
                if (part.type === 'code') {
                    const langTag = part.language !== 'plaintext' ? `<div class="language-tag">${part.language}</div>` : '';
                    return `${langTag}<pre><code class="language-${part.language}">${part.content}</code></pre>`;
                } else {
                    return part.content
                        .replace(/`([^`]+)`/g, (match, code) => `<code>${code}</code>`) 
                        .replace(/\n/g, '<br>'); 
                }
            }).join('');
        },
        highlightElement(element) {
            if (window.hljs && element) {
                try {
                    window.hljs.highlightElement(element);
                } catch (e) {
                    console.error("Highlight.js error:", e, "on element:", element);
                }
            }
        },
        processMessageContent(messageElement) {
            if (!messageElement || !window.hljs) return;
            const codeBlocks = messageElement.querySelectorAll('.message-content pre code, .thinking-content pre code');
            codeBlocks.forEach(this.highlightElement);
            const contentDiv = messageElement.querySelector('.message-content');
            if (contentDiv) {
                 contentDiv.classList.toggle('short-message', contentDiv.scrollHeight <= SHORT_MESSAGE_THRESHOLD);
            }
        },
        adjustTextareaHeight(textarea) {
            textarea.style.height = 'auto'; 
            textarea.style.height = `${textarea.scrollHeight}px`;
        },
        scrollToBottom() {
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        },
         scrollToTop() {
            elements.chatMessages.scrollTop = 0;
        },
        toggleStopButton(showStop) {
            const btn = elements.sendButton;
            if (showStop) {
                btn.innerHTML = '<i class="fas fa-stop"></i>';
                btn.title = 'Stop generation';
                btn.classList.add('stop-button');
                btn.removeEventListener('click', handleSendMessage);
                btn.onclick = handleStopGeneration; 
            } else {
                btn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                btn.title = 'Send message';
                btn.classList.remove('stop-button');
                btn.removeEventListener('click', handleStopGeneration); 
                btn.onclick = handleSendMessage; 
            }
        },
        updateUploadStatus(message, statusClass) {
            elements.uploadStatus.textContent = message;
            elements.uploadStatus.className = statusClass; 
        },
        updateUploadStatusFinal(successCount, errorCount, totalFiles) {
            let message = '';
            let statusClass = '';
            if (errorCount === 0 && successCount > 0) {
                message = `Successfully uploaded ${successCount} file(s).`;
                statusClass = 'success';
            } else if (successCount === 0 && errorCount > 0) {
                message = `Upload failed for ${errorCount} file(s).`;
                statusClass = 'error';
            } else if (successCount > 0 && errorCount > 0) {
                message = `Uploaded ${successCount} of ${totalFiles} files (${errorCount} failed).`;
                statusClass = 'warning'; 
            } else {
                 message = 'No files were uploaded.'; 
                 statusClass = '';
            }
            this.updateUploadStatus(message, statusClass);
            setTimeout(() => {
                this.updateUploadStatus('', '');
            }, 4000);
        },
        showModal(modalElement) {
            modalElement.style.display = 'flex';
        },
        hideModal(modalElement) {
            modalElement.style.display = 'none';
        },
        createKittIndicator() {
            const existing = document.querySelector('.typing-indicator');
            if (existing) return existing; 
            const wrapper = document.createElement('div');
            wrapper.className = 'typing-indicator';
            const kittDiv = document.createElement('div');
            kittDiv.className = 'typing-kitt';
            const scanner = document.createElement('div');
            scanner.className = 'scanner';
            kittDiv.appendChild(scanner);
            const numRectangles = 10;
            const rectWidth = (200 / numRectangles) - 1; 
            for (let i = 0; i < numRectangles; i++) {
                const rect = document.createElement('div');
                rect.className = 'rectangle';
                rect.style.width = `${rectWidth}px`;
                kittDiv.appendChild(rect);
            }
            wrapper.appendChild(kittDiv);
            const animateRectangles = () => {
                if (!wrapper.isConnected) { 
                    clearInterval(wrapper.intervalId);
                    return;
                }
                const kittRect = kittDiv.getBoundingClientRect();
                const scannerRect = scanner.getBoundingClientRect();
                if (kittRect.width === 0 || scannerRect.width === 0) return;
                const scannerPos = scannerRect.left - kittRect.left + (scannerRect.width / 2); 
                const rectangles = kittDiv.querySelectorAll('.rectangle');
                rectangles.forEach(rect => {
                    const rectRect = rect.getBoundingClientRect();
                    const rectCenterPos = rectRect.left - kittRect.left + (rectRect.width / 2);
                    const distance = Math.abs(scannerPos - rectCenterPos);
                    const maxDistance = 35; 
                    if (distance < maxDistance) {
                        const intensity = 1 - (distance / maxDistance);
                        const red = Math.floor(100 + (155 * intensity)); 
                        rect.style.backgroundColor = `rgb(${red}, 0, 0)`;
                        rect.style.boxShadow = `0 0 ${Math.floor(intensity * 5)}px rgba(255, 0, 0, 0.5)`;
                    } else {
                        rect.style.backgroundColor = '#600'; 
                        rect.style.boxShadow = 'none';
                    }
                });
            };
            wrapper.intervalId = setInterval(animateRectangles, 50); 
            return wrapper;
        },
        hideTypingIndicator(indicatorElement) {
            if (indicatorElement && indicatorElement.intervalId) {
                clearInterval(indicatorElement.intervalId);
            }
            if (indicatorElement && indicatorElement.parentNode) {
                indicatorElement.remove();
            }
             const fallbackIndicator = document.querySelector('.typing-indicator');
             if (fallbackIndicator) {
                 if (fallbackIndicator.intervalId) clearInterval(fallbackIndicator.intervalId);
                 fallbackIndicator.remove();
             }
        },
        createMessageInserter(precedingMessageId) {
            const inserterDiv = document.createElement('div');
            inserterDiv.className = 'message-inserter';
            inserterDiv.dataset.precedingMessageId = precedingMessageId || '';
            const icon = document.createElement('i');
            icon.className = 'fas fa-plus insert-icon';
            const leftArea = document.createElement('div');
            leftArea.className = 'insert-area left';
            leftArea.title = 'Insert Assistant message here';
            const rightArea = document.createElement('div');
            rightArea.className = 'insert-area right';
            rightArea.title = 'Insert User message here';
            inserterDiv.append(leftArea, rightArea, icon); 
            return inserterDiv;
        },
        showNewMessageInput(inserterElement, role, precedingMessageId) {
            const existingInput = document.querySelector('.new-message-input-area');
            if (existingInput) {
                existingInput.remove();
                 document.querySelectorAll('.message-inserter.inserting').forEach(el => el.classList.remove('inserting'));
            }
            document.querySelectorAll('.message.editing').forEach(el => {
                const contentDiv = el.querySelector('.message-content');
                const originalHTML = el.dataset.originalHtml || ''; 
                if (contentDiv && originalHTML) {
                    this.cancelEdit(contentDiv, originalHTML, el);
                }
            });
            const inputArea = document.createElement('div');
            inputArea.className = 'new-message-input-area';
            const textarea = document.createElement('textarea');
            textarea.placeholder = `Enter new ${role} message... (Shift+Enter for newline)`;
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'input-buttons';
            const saveBtn = document.createElement('button');
            saveBtn.textContent = `Save ${role === 'user' ? 'User' : 'Assistant'}`;
            saveBtn.className = `save-btn ${role}`; 
            saveBtn.onclick = () => { 
                const content = textarea.value.trim();
                handleSaveInsertedMessage(precedingMessageId, role, content, inputArea, inserterElement);
            };
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'cancel-btn';
            cancelBtn.onclick = () => { 
                inputArea.remove();
                inserterElement.classList.remove('inserting');
            };
            textarea.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveBtn.click(); 
                } else if (e.key === 'Escape') {
                    cancelBtn.click(); 
                }
            });
            buttonsDiv.append(saveBtn, cancelBtn);
            inputArea.append(textarea, buttonsDiv);
            inserterElement.parentNode.insertBefore(inputArea, inserterElement.nextSibling);
            inserterElement.classList.add('inserting'); 
            textarea.focus();
        },
        insertNewMessageUI(targetInserter, newMessageData) {
            if (!targetInserter) {
                console.error("Target inserter not found for UI update.");
                api.fetchConversationHistory(); 
                return;
            }
            const sender = newMessageData.role === 'assistant' ? 'bot' : newMessageData.role;
            const newMessageElement = this.createMessageElement(
                newMessageData.content,
                sender,
                newMessageData.thinking || null,
                newMessageData.id
            );
            const newInserterElement = this.createMessageInserter(newMessageData.id);
            targetInserter.parentNode.insertBefore(newMessageElement, targetInserter);
            targetInserter.parentNode.insertBefore(newInserterElement, targetInserter);
            this.processMessageContent(newMessageElement);
            this.scrollToBottom(); 
        },
        showEditInput(messageElement, messageId) {
            const contentDiv = messageElement.querySelector('.message-content');
            const actionsDiv = messageElement.querySelector('.message-actions');
            const editBtn = actionsDiv?.querySelector('.edit-message-btn');
            if (!contentDiv || contentDiv.querySelector('.edit-textarea')) {
                return; 
            }
            const nextInserter = messageElement.nextElementSibling;
            if (nextInserter && nextInserter.classList.contains('message-inserter')) {
                nextInserter.style.display = 'none';
            }
            messageElement.classList.add('editing');
            const originalHTML = contentDiv.innerHTML;
            messageElement.dataset.originalHtml = originalHTML; 
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalHTML.replace(/<br\s*\/?>/gi, '\n'); 
            const originalText = tempDiv.textContent || '';
            contentDiv.innerHTML = `
                <textarea class="edit-textarea">${originalText}</textarea>
                <div class="input-buttons">
                    <button class="save-edit-btn">Save & Resubmit</button>
                    <button class="cancel-edit-btn">Cancel</button>
                </div>
            `;
            if (editBtn) editBtn.disabled = true; 
            const saveBtn = contentDiv.querySelector('.save-edit-btn');
            const cancelBtn = contentDiv.querySelector('.cancel-edit-btn');
            const textarea = contentDiv.querySelector('.edit-textarea');
            this.adjustTextareaHeight(textarea); 
            textarea.focus();
            textarea.select();
            saveBtn.onclick = () => {
                const newContent = textarea.value.trim();
                handleSaveEdit(messageId, newContent, originalHTML, contentDiv, messageElement); 
            };
            cancelBtn.onclick = () => {
                this.cancelEdit(contentDiv, originalHTML, messageElement);
            };
            textarea.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveBtn.click(); 
                } else if (e.key === 'Escape') {
                    cancelBtn.click(); 
                }
            });
             textarea.addEventListener('input', () => this.adjustTextareaHeight(textarea));
        },
        cancelEdit(contentDiv, originalHTML, messageElement) {
            contentDiv.innerHTML = originalHTML;
            messageElement.classList.remove('editing');
            delete messageElement.dataset.originalHtml; 
            const actionsDiv = messageElement.querySelector('.message-actions');
            const editBtn = actionsDiv?.querySelector('.edit-message-btn');
            if (editBtn) editBtn.disabled = false; 
            const nextInserter = messageElement.nextElementSibling;
            if (nextInserter && nextInserter.classList.contains('message-inserter')) {
                nextInserter.style.display = ''; 
            }
            this.processMessageContent(messageElement);
        },
        showLoadingIndicator(element) {
            console.log("Loading indicator shown (placeholder)");
        },
        hideLoadingIndicator(element) {
             console.log("Loading indicator hidden (placeholder)");
        }
    }; 
    initializeApp(); 
    async function initializeApp() {
        console.log("Initializing Ollama Chat Interface...");
        elements.topMessageInserter = ui.createMessageInserter(null); 
        elements.topMessageInserter.id = 'top-message-inserter';
        elements.chatMessages.appendChild(elements.topMessageInserter); 
        loadResources();
        setupEventListeners();
        await Promise.all([
            api.fetchModels(), 
            api.fetchThreads(), 
            api.fetchFiles(), 
        ]);
        await api.fetchConversationHistory(); 
        ui.updateSelectedFilesDisplay(); 
        ui.adjustTextareaHeight(elements.messageInput); 
        console.log("Initialization complete.");
    }
    function loadResources() {
        loadScript('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js', () => {
            console.log("Highlight.js script loaded.");
            loadCSS('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark-dimmed.min.css');
            // Initial highlighting if content loaded before script
            document.querySelectorAll('.message pre code, .thinking-content pre code').forEach(ui.highlightElement); // ui is defined
        });
    }
    function loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        script.onerror = () => console.error(`Failed to load script: ${url}`);
        document.head.appendChild(script);
    }
    function loadCSS(url) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = url;
        link.onload = () => console.log(`CSS loaded: ${url}`);
        link.onerror = () => console.error(`Failed to load CSS: ${url}`);
        document.head.appendChild(link);
    }
    function setupEventListeners() {
        elements.sendButton.addEventListener('click', handleSendMessage);
        elements.messageInput.addEventListener('keydown', handleMessageInputKeydown);
        elements.messageInput.addEventListener('input', () => ui.adjustTextareaHeight(elements.messageInput)); 
        elements.dragDropArea.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', handleFileInputChange);
        setupDragDropListeners();
        elements.clearConversationBtn.addEventListener('click', handleClearConversation);
        elements.newThreadBtn.addEventListener('click', handleNewThread);
        elements.threadsContainer.addEventListener('click', handleThreadContainerClick); 
        elements.settingsButton.addEventListener('click', handleSettingsButtonClick);
        elements.systemPromptInput.addEventListener('input', handleSystemPromptInput);
        elements.settingsModal.addEventListener('click', handleModalBackgroundClick);
        elements.confirmRenameBtn.addEventListener('click', handleConfirmRename);
        elements.cancelRenameBtn.addEventListener('click', () => ui.hideModal(elements.renameThreadModal)); 
        elements.renameThreadModal.addEventListener('click', handleModalBackgroundClick);
        elements.filesContainer.addEventListener('click', handleFilesContainerClick); 
        elements.selectedFilesDisplay.addEventListener('click', handleSelectedFilesDisplayClick); 
        elements.chatMessages.addEventListener('click', handleChatMessagesClick); 
    }
    function setupDragDropListeners() {
        const area = elements.dragDropArea;
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            area.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            area.addEventListener(eventName, () => area.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            area.addEventListener(eventName, () => area.classList.remove('dragover'), false);
        });
        area.addEventListener('drop', handleDrop, false);
    }
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    function handleMessageInputKeydown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
        }
    }
    function handleFileInputChange() {
        if (elements.fileInput.files && elements.fileInput.files.length > 0) {
            uploadFiles(elements.fileInput.files);
        }
    }
    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        if (files && files.length > 0) {
            uploadFiles(files);
        }
    }
    function handleFilesContainerClick(e) {
        const target = e.target;
        if (target.classList.contains('file-checkbox')) {
            handleFileSelectionChange(target);
        }
        else if (target.closest('.delete-btn')) {
            const fileItem = target.closest('.file-item');
            const filename = fileItem?.dataset.filename;
            if (filename) {
                handleDeleteFile(filename);
            }
        }
    }
    function handleSelectedFilesDisplayClick(e) {
        if (e.target.classList.contains('remove-file')) {
            const fileTag = e.target.closest('.selected-file-tag');
            const filename = fileTag?.dataset.filename;
            if (filename) {
                state.selectedFiles = state.selectedFiles.filter(f => f !== filename);
                const checkbox = elements.filesContainer.querySelector(`.file-checkbox[data-filename="${filename}"]`);
                if (checkbox) {
                    checkbox.checked = false;
                }
                ui.updateSelectedFilesDisplay(); 
            }
        }
    }
    function handleFileSelectionChange(checkbox) {
        const filename = checkbox.dataset.filename;
        if (checkbox.checked) {
            if (!state.selectedFiles.includes(filename)) {
                state.selectedFiles.push(filename);
            }
        } else {
            state.selectedFiles = state.selectedFiles.filter(f => f !== filename);
        }
        ui.updateSelectedFilesDisplay(); 
    }
    async function handleDeleteFile(filename) {
        if (!confirm(`Permanently delete the file "${filename}" from the server? This cannot be undone.`)) {
            return;
        }
        ui.showLoadingIndicator(elements.filesContainer); 
        const result = await api.deleteFile(filename); 
        ui.hideLoadingIndicator(elements.filesContainer); 
        if (result.success) {
            state.selectedFiles = state.selectedFiles.filter(file => file !== filename);
            ui.updateSelectedFilesDisplay(); 
            await api.fetchFiles(); 
        } else {
            console.error('Error deleting file:', result.error);
            alert(`Failed to delete file: ${result.error || 'Unknown error'}`);
        }
    }
    async function handleClearConversation() {
        if (!confirm(`Delete all messages in the current thread "${getCurrentThreadName()}"? This cannot be undone.`)) {
            return;
        }
        const result = await api.clearConversation(); 
        if (result.success) {
            ui.clearChatMessagesAndInserters(); 
            ui.addWelcomeMessage(); 
            console.log('Conversation cleared. Triggering title generation check.');
            await generateThreadTitleIfNeeded();
        } else {
            console.error('Failed to clear conversation:', result.error);
            alert('Failed to clear conversation.');
        }
    }
    async function handleNewThread() {
        if (state.isStreaming) {
            alert("Please wait for the current response to finish before creating a new thread.");
            return;
        }
        const result = await api.createNewThread(); 
        if (result.success && result.data?.thread) {
            state.currentThreadId = result.data.thread.id;
            await api.fetchThreads(); 
            ui.clearChatMessagesAndInserters(); 
            ui.addWelcomeMessage(); 
            ui.scrollToBottom(); 
        } else {
            console.error('Error creating thread:', result.error);
            alert('Error creating new thread.');
        }
    }
    function handleThreadContainerClick(e) {
        const threadItem = e.target.closest('.thread-item');
        if (!threadItem) return;
        const threadId = threadItem.dataset.threadId;
        if (!threadId) return;
        if (e.target.closest('.rename-btn')) {
            const currentName = threadItem.querySelector('.thread-name')?.textContent || '';
            handleRenameThreadClick(threadId, currentName);
        } else if (e.target.closest('.delete-btn')) {
            const threadName = threadItem.querySelector('.thread-name')?.textContent || 'this thread';
            handleDeleteThreadClick(threadId, threadName);
        } else {
            handleActivateThread(threadId);
        }
    }
    async function handleActivateThread(threadId) {
        if (state.currentThreadId === threadId || state.isStreaming) {
            console.log(`Thread ${threadId} already active or streaming in progress. Activation skipped.`);
            return;
        }
        console.log(`Activating thread: ${threadId}`);
        const result = await api.activateThread(threadId); 
        if (result.success && result.data) {
            state.currentThreadId = result.data.thread_id;
            await api.fetchThreads(); 
            ui.renderMessages(result.data.history || []); 
            ui.scrollToTop(); 
        } else {
            console.error('Error activating thread:', result.error);
            alert('Error switching thread.');
        }
    }
     function handleRenameThreadClick(threadId, currentName) {
        state.renameThreadId = threadId;
        elements.threadNameInput.value = currentName;
        ui.showModal(elements.renameThreadModal); 
        elements.threadNameInput.focus();
        elements.threadNameInput.select();
    }
    async function handleConfirmRename() {
        const newName = elements.threadNameInput.value.trim();
        if (newName && state.renameThreadId) {
            const result = await api.renameThread(state.renameThreadId, newName); 
            if (result.success) {
                ui.hideModal(elements.renameThreadModal); 
                await api.fetchThreads(); 
            } else {
                console.error('Error renaming thread:', result.error);
                alert(`Failed to rename thread: ${result.error || 'Unknown error'}`);
            }
        } else if (!newName) {
            alert("Thread name cannot be empty.");
        }
    }
    async function handleDeleteThreadClick(threadId, threadName) {
        if (state.isStreaming) {
             alert("Please wait for the current response to finish before deleting a thread.");
             return;
        }
        if (!confirm(`Are you sure you want to delete the thread "${threadName}"? This cannot be undone.`)) {
            return;
        }
        const result = await api.deleteThread(threadId); 
        if (result.success && result.data?.active_thread) {
            await handleActivateThread(result.data.active_thread);
        } else {
            console.error('Error deleting thread:', result.error);
            alert('Error deleting thread.');
            await api.fetchThreads(); 
        }
    }
    function handleSettingsButtonClick() {
        elements.systemPromptInput.value = state.systemPrompt;
        ui.showModal(elements.settingsModal); 
    }
    function handleSystemPromptInput() {
        if (state.saveTimeout) clearTimeout(state.saveTimeout);
        elements.saveStatusDiv.textContent = 'Saving...';
        elements.saveStatusDiv.style.color = 'var(--text-secondary)';
        state.saveTimeout = setTimeout(() => {
            state.systemPrompt = elements.systemPromptInput.value;
            localStorage.setItem('systemPrompt', state.systemPrompt);
            elements.saveStatusDiv.textContent = 'Saved!';
            elements.saveStatusDiv.style.color = 'var(--success-color)';
            console.log("System prompt saved to localStorage.");
            setTimeout(() => {
                elements.saveStatusDiv.textContent = '';
            }, 2500);
        }, 1000);
    }
    function handleModalBackgroundClick(event) {
        if (event.target === elements.settingsModal) {
            ui.hideModal(elements.settingsModal); 
        }
        if (event.target === elements.renameThreadModal) {
            ui.hideModal(elements.renameThreadModal); 
        }
    }
    function handleChatMessagesClick(e) {
        const target = e.target;
        const messageElement = target.closest('.message');
        const inserterElement = target.closest('.message-inserter');
        if (messageElement) {
            const messageId = messageElement.dataset.messageId;
            if (target.closest('.delete-message-btn')) {
                handleDeleteMessageClick(messageId, messageElement);
            } else if (target.closest('.edit-message-btn')) {
                handleEditMessageClick(messageId, messageElement);
            }
        }
        else if (inserterElement) {
            const isEditing = document.querySelector('.message.editing');
            const isInserting = document.querySelector('.new-message-input-area');
            if (isEditing || isInserting) {
                console.log("Ignoring inserter click while editing/inserting.");
                return;
            }
            const precedingMessageId = inserterElement.dataset.precedingMessageId || null;
            if (target.classList.contains('insert-area')) {
                const role = target.classList.contains('left') ? 'assistant' : 'user';
                ui.showNewMessageInput(inserterElement, role, precedingMessageId); 
            }
        }
    }
     async function handleDeleteMessageClick(messageId, messageElement) {
        if (!messageId || messageId.startsWith('temp-')) {
            console.warn('Cannot delete unsaved or temporary message.');
            alert('Cannot delete a message that hasn\'t been saved yet.');
            return;
        }
        if (state.isStreaming) {
            alert('Please wait until generation is complete before deleting messages.');
            return;
        }
        if (confirm("Delete this message and ALL subsequent messages in this thread? This cannot be undone.")) {
            const result = await api.deleteMessage(messageId); 
            if (result.success) {
                await api.fetchConversationHistory(); 
            } else {
                alert(`Failed to delete message: ${result.error || 'Server error'}`);
                console.error('Failed to delete message:', result.error);
            }
        }
    }
    function handleEditMessageClick(messageId, messageElement) {
        if (!messageId || messageId.startsWith('temp-')) {
            console.warn('Cannot edit unsaved or temporary message.');
            alert('Cannot edit a message that hasn\'t been saved yet.');
            return;
        }
        if (state.isStreaming) {
            alert('Please wait until generation is complete before editing.');
            return;
        }
        if (document.querySelector('.edit-textarea')) {
            console.warn("Another edit is already in progress.");
            return;
        }
        ui.showEditInput(messageElement, messageId); 
    }
    async function handleSaveEdit(messageId, newContent, originalHTML, contentDiv, messageElement) {
        if (newContent) {
            const result = await api.updateMessage(messageId, newContent); 
            if (result.success) {
                await api.fetchConversationHistory(); 
            } else {
                alert(`Failed to save edit: ${result.error || 'Server error'}`);
                console.error("Failed to save edit:", result.error);
                ui.cancelEdit(contentDiv, originalHTML, messageElement); 
            }
        } else {
            ui.cancelEdit(contentDiv, originalHTML, messageElement); 
        }
    }
    async function handleSaveInsertedMessage(precedingMessageId, role, content, inputArea, inserterElement) {
        if (content) {
            const result = await api.insertMessage(precedingMessageId, role, content); 
            if (result.success && result.data?.message) {
                ui.insertNewMessageUI(inserterElement, result.data.message); 
                inputArea.remove();
                inserterElement.classList.remove('inserting');
            } else {
                alert(`Failed to insert message: ${result.error || 'Server error'}`);
                console.error('Error inserting message:', result.error);
                inputArea.remove();
                inserterElement.classList.remove('inserting');
            }
        } else {
            inputArea.remove();
            inserterElement.classList.remove('inserting');
        }
    }
    function handleStopGeneration() {
        if (state.abortController) {
            console.log("Aborting chat stream request...");
            state.abortController.abort();
        } else {
            console.warn("Stop generation called but no AbortController found.");
        }
    }
    async function handleSendMessage() {
        const messageContent = elements.messageInput.value.trim();
        const selectedModel = elements.modelDropdown.value;
        if (!messageContent) {
            alert("Please enter a message.");
            return;
        }
        if (!selectedModel || selectedModel === "loading" || selectedModel === "") {
            alert("Please select a model.");
            return;
        }
        if (state.isStreaming) {
            console.warn("Attempted to send message while streaming.");
            return;
        }
        state.isStreaming = true;
        ui.toggleStopButton(true); 
        elements.messageInput.disabled = true;
        const tempUserMessageId = `temp-user-${Date.now()}`;
        const userMessageElement = ui.addMessageAndInserterToChat(messageContent, 'user', null, tempUserMessageId); 
        ui.processMessageContent(userMessageElement); 
        elements.messageInput.value = '';
        ui.adjustTextareaHeight(elements.messageInput); 
        ui.scrollToBottom(); 
        const typingIndicator = ui.createKittIndicator(); 
        elements.chatMessages.appendChild(typingIndicator);
        ui.scrollToBottom(); 
        state.abortController = new AbortController();
        const payload = {
            model: selectedModel,
            message: messageContent,
            references: state.selectedFiles,
            systemPrompt: state.systemPrompt,
        };
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream'
                },
                body: JSON.stringify(payload),
                credentials: 'include',
                signal: state.abortController.signal
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Network response was not ok: ${response.status} ${response.statusText}. ${errorText}`);
            }
            if (!response.body) {
                throw new Error('Response body is null');
            }
            await processChatStream(response.body, typingIndicator);
            await generateThreadTitleIfNeeded();
        } catch (error) {
            console.error('Error during chat fetch/stream:', error);
            ui.hideTypingIndicator(typingIndicator); 
            if (error.name === 'AbortError') {
                console.log('Request was aborted by user.');
                const lastBotMessage = elements.chatMessages.querySelector('.message.bot:last-of-type');
                 if (lastBotMessage && lastBotMessage.dataset.messageId?.startsWith('temp-bot-')) {
                     const contentDiv = lastBotMessage.querySelector('.message-content');
                     if (contentDiv) {
                         contentDiv.innerHTML += '<p><em>[Generation stopped by user]</em></p>';
                     }
                 }
                 await api.fetchConversationHistory(); 
            } else {
                ui.addMessageAndInserterToChat( 
                    `Error: ${error.message || 'Could not communicate with the backend.'}`,
                    'bot',
                    null,
                    `temp-error-${Date.now()}`
                );
                ui.scrollToBottom(); 
            }
        } finally {
            state.isStreaming = false;
            state.abortController = null;
            ui.toggleStopButton(false); 
            elements.messageInput.disabled = false;
            ui.hideTypingIndicator(typingIndicator); 
            elements.messageInput.focus();
        }
    }
    async function processChatStream(streamBody, typingIndicator) {
        const reader = streamBody.getReader();
        const decoder = new TextDecoder();
        let accumulatedContent = '';
        let accumulatedThinking = '';
        let hasThinking = false;
        let botMessageElement = null;
        let serverResponseReceived = false;
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    console.log("Stream finished.");
                    if (!serverResponseReceived) {
                        console.warn("Stream ended without explicit 'done' event from server.");
                        if (botMessageElement) {
                            ui.processMessageContent(botMessageElement); 
                            await api.fetchConversationHistory(); 
                        }
                    }
                    break;
                }
                const chunk = decoder.decode(value, { stream: true });
                const eventLines = chunk.split('\n\n');
                for (const line of eventLines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.substring(6));
                            if (data.content) {
                                serverResponseReceived = true;
                                accumulatedContent += data.content;
                                if (!hasThinking && accumulatedContent.includes('</think>')) {
                                    const parts = accumulatedContent.split('</think>', 2);
                                    accumulatedThinking = parts[0].replace('<think>', '').trimStart();
                                    accumulatedContent = parts[1].trimStart();
                                    hasThinking = true;
                                }
                                if (!botMessageElement) {
                                    ui.hideTypingIndicator(typingIndicator); 
                                    const tempBotId = `temp-bot-${Date.now()}`;
                                    botMessageElement = ui.addMessageAndInserterToChat( 
                                        accumulatedContent,
                                        'bot',
                                        hasThinking ? accumulatedThinking : null,
                                        tempBotId
                                    );
                                } else {
                                    ui.updateMessageContent(botMessageElement, accumulatedContent, hasThinking ? accumulatedThinking : null); 
                                }
                                ui.scrollToBottom(); 
                            }
                            if (data.done) {
                                console.log('Received done signal from stream.');
                                serverResponseReceived = true;
                                if (botMessageElement) {
                                    ui.updateMessageContent(botMessageElement, accumulatedContent, hasThinking ? accumulatedThinking : null); 
                                    ui.processMessageContent(botMessageElement); 
                                    await api.fetchConversationHistory(); 
                                } else {
                                    console.warn("Received 'done' signal but no bot message element was created.");
                                }
                                return;
                            }
                        } catch (e) {
                            console.error('Error parsing SSE data:', e, "Raw Line:", line);
                        }
                    }
                }
            } 
        } catch (streamError) {
             console.error("Error reading from stream:", streamError);
            throw streamError;
        } finally {
            reader.releaseLock();
            console.log("Stream reader released.");
        }
    }
    async function uploadFiles(files) {
        if (state.uploadInProgress) {
            alert("Another upload is already in progress. Please wait.");
            return;
        }
        if (!files || files.length === 0) return;
        state.uploadInProgress = true;
        ui.updateUploadStatus('Uploading...', 'uploading'); 
        let successCount = 0;
        let errorCount = 0;
        const totalFiles = files.length;
        const uploadPromises = [];
        for (const file of files) {
            const formData = new FormData();
            formData.append('file', file);
            const uploadPromise = fetch('/api/upload', {
                method: 'POST',
                body: formData,
                credentials: 'include'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    successCount++;
                    console.log(`Successfully uploaded: ${file.name}`);
                } else {
                    errorCount++;
                    console.error(`Upload failed for ${file.name}:`, data.error);
                }
            })
            .catch(error => {
                errorCount++;
                console.error(`Error uploading ${file.name}:`, error);
            });
            uploadPromises.push(uploadPromise);
        }
        await Promise.all(uploadPromises);
        state.uploadInProgress = false;
        ui.updateUploadStatusFinal(successCount, errorCount, totalFiles); 
        elements.fileInput.value = '';
        await api.fetchFiles(); 
    }
    async function generateThreadTitleIfNeeded() {
        const messageElements = elements.chatMessages.querySelectorAll('.message');
        const currentThreadName = getCurrentThreadName();
        const shouldGenerate = messageElements.length >= 2 &&
                               messageElements.length <= 6 &&
                               (!currentThreadName || currentThreadName.toLowerCase() === 'new thread');
        if (!shouldGenerate) {
            return;
        }
        const selectedModel = elements.modelDropdown.value;
        if (!selectedModel || selectedModel === "loading" || selectedModel === "") {
            console.warn("Cannot generate title: No model selected.");
            return;
        }
        console.log(`Conditions met. Attempting to generate title for thread ${state.currentThreadId}...`);
        const conversation = {
            messages: [],
            threadId: state.currentThreadId,
            model: selectedModel
        };
        messageElements.forEach(el => {
            const role = el.classList.contains('user') ? 'user' : 'assistant';
            const contentEl = el.querySelector('.message-content');
            const content = contentEl?.textContent?.trim() || '';
            if (content) {
                conversation.messages.push({ role, content });
            }
        });
        const result = await api.generateTitle(conversation); 
        if (result.success && result.data?.title) {
            console.log(`Generated title: "${result.data.title}". Renaming thread.`);
            const renameResult = await api.renameThread(state.currentThreadId, result.data.title); 
            if (renameResult.success) {
                await api.fetchThreads(); 
            } else {
                console.error("Failed to rename thread with generated title:", renameResult.error);
            }
        } else if (!result.success) {
            console.error('Error generating thread title:', result.error);
        } else {
            console.log("Title generation endpoint succeeded but returned no title.");
        }
    }
    function getCurrentThreadName() {
        const activeThreadElement = elements.threadsContainer.querySelector('.thread-item.active .thread-name');
        return activeThreadElement?.textContent || null;
    }
});
